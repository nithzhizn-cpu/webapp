<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpySignal WebApp ‚Äî E2EE Calls & Files</title>

    <style>
        :root {
            --bg: #05070c;
            --bg-alt: #0c1018;
            --card: #121826;
            --accent: #3d7bfd;
            --accent-soft: rgba(61, 123, 253, 0.15);
            --danger: #ff4d4d;
            --text: #ffffff;
            --text-muted: #8a93a5;
            --border: #1f2433;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #182744 0, #05070c 55%);
            color: var(--text);
        }

        .app-shell {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 12px;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px 4px;
        }

        .logo-circle {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 1px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 12px rgba(0, 255, 180, 0.35);
            background: radial-gradient(circle at 30% 20%, #26ffe0 0, #060811 55%);
        }

        .logo-circle span {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .header-text h1 {
            font-size: 18px;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tagline {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .pill {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid rgba(61, 123, 253, 0.4);
            background: rgba(8, 15, 32, 0.9);
            text-transform: uppercase;
            letter-spacing: .06em;
        }

        .status-bar {
            margin: 6px 4px 8px;
            padding: 7px 10px;
            border-radius: 999px;
            display: flex;
            align-items: center;
            font-size: 11px;
            background: rgba(3, 10, 25, 0.9);
            border: 1px solid var(--border);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            box-shadow: 0 0 10px rgba(77, 255, 153, 0.8);
            background: radial-gradient(circle, #81ffb7 0, #08c96a 60%);
        }

        .status-dot.offline {
            background: radial-gradient(circle, #ff9b9b 0, #ff4040 60%);
            box-shadow: 0 0 8px rgba(255, 64, 64, 0.8);
        }

        .status-label {
            font-weight: 500;
            margin-right: 4px;
        }

        .status-url {
            color: var(--text-muted);
            opacity: .8;
        }

        .card {
            background: rgba(11, 15, 27, 0.96);
            border-radius: 16px;
            padding: 14px;
            border: 1px solid var(--border);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            margin-bottom: 10px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .card-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .field-label {
            font-size: 11px;
            color: var(--text-muted);
            margin: 6px 2px 2px;
        }

        .input {
            width: 100%;
            padding: 9px 11px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #060a13;
            color: var(--text);
            font-size: 14px;
            outline: none;
        }

        .input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(61, 123, 253, 0.6);
        }

        .btn {
            width: 100%;
            padding: 10px 14px;
            border-radius: 10px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            background: linear-gradient(135deg, #3d7bfd, #47d3ff);
            color: #fff;
            margin-top: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:active {
            transform: translateY(1px);
            filter: brightness(.95);
        }

        .btn-secondary {
            background: rgba(7, 12, 26, 0.9);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-small {
            width: auto;
            padding: 6px 10px;
            font-size: 11px;
            border-radius: 999px;
        }

        .btn-danger {
            background: rgba(120, 18, 33, 0.95);
            border: 1px solid rgba(255, 102, 119, 0.8);
            color: #ffd7dd;
        }

        .hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .two-blocks {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .search-results {
            max-height: 160px;
            overflow-y: auto;
            margin-top: 6px;
        }

        .user-item {
            background: #0c1018;
            border-radius: 10px;
            padding: 8px 9px;
            margin-bottom: 6px;
            border: 1px solid rgba(54, 63, 90, 0.8);
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }

        .user-item:hover {
            border-color: var(--accent);
            background: rgba(14, 20, 37, 0.95);
        }

        .user-name {
            font-size: 13px;
            font-weight: 500;
        }

        .user-id {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 1px;
        }

        .chat-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 4px;
        }

        .chat-peer {
            font-size: 13px;
            font-weight: 500;
        }

        .chat-peer span {
            color: var(--accent);
        }

        .typing-indicator {
            font-size: 11px;
            color: var(--text-muted);
            min-height: 14px;
        }

        .call-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .call-btn {
            padding: 5px 9px;
            border-radius: 999px;
            border: 1px solid rgba(61, 123, 253, 0.6);
            background: rgba(10, 20, 40, 0.95);
            color: #e5f0ff;
            font-size: 11px;
            cursor: pointer;
        }

        .call-btn.danger {
            border-color: rgba(255, 102, 119, 0.8);
            background: rgba(80, 16, 26, 0.95);
            color: #ffd8dd;
        }

        .call-status {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 3px;
            min-height: 14px;
        }

        .chat-window {
            border-radius: 12px;
            border: 1px solid var(--border);
            background: radial-gradient(circle at top left, rgba(61, 123, 253, .08) 0, #05070c 40%);
            height: 270px;
            padding: 8px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .msg {
            padding: 7px 10px;
            border-radius: 11px;
            font-size: 13px;
            max-width: 78%;
            line-height: 1.4;
            background: #171f32;
            animation: fadeUp .18s ease-out forwards;
            opacity: 0;
            transform: translateY(4px);
        }

        .msg.me {
            margin-left: auto;
            background: linear-gradient(135deg, #3d7bfd, #40c3ff);
        }

        .msg-meta {
            font-size: 9px;
            color: #b8c2d8;
            margin-top: 2px;
        }

        .msg-file {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .msg-file-title {
            font-size: 13px;
        }

        .msg-file-meta {
            font-size: 10px;
            color: #d4def5;
        }

        .msg-file-btn {
            margin-top: 2px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid rgba(207, 222, 255, 0.7);
            background: rgba(8, 16, 34, 0.95);
            color: #f3f5ff;
            font-size: 11px;
            cursor: pointer;
            align-self: flex-start;
        }

        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-input-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
        }

        .chat-input {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chat-attach-btn {
            width: 34px;
            height: 34px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #090d18;
            color: #e5ecff;
            font-size: 17px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .chat-send-btn {
            width: 44px;
            height: 38px;
            border-radius: 12px;
            background: var(--accent);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .chat-send-btn span {
            font-size: 18px;
        }

        .footer-hint {
            margin-top: 6px;
            text-align: center;
            font-size: 10px;
            color: var(--text-muted);
        }

        .footer-hint strong {
            color: #61ffa8;
        }

        .badge-e2ee {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid rgba(140, 255, 195, 0.8);
            background: rgba(9, 24, 20, 0.9);
            color: #9dffd0;
            display: inline-flex;
            align-items: center;
            gap: 3px;
        }

        .toast {
            position: fixed;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            background: #141a28;
            border-radius: 999px;
            border: 1px solid var(--border);
            padding: 7px 14px;
            font-size: 12px;
            display: none;
            align-items: center;
            gap: 6px;
            z-index: 999;
        }

        .toast.show {
            display: inline-flex;
            animation: fadeToast .25s ease-out;
        }

        .toast-error {
            border-color: rgba(255, 85, 85, 0.6);
            color: #ffb3b3;
        }

        @keyframes fadeToast {
            from {
                opacity: 0;
                transform: translate(-50%, 4px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        audio {
            display: none;
        }
    </style>
</head>

<body>
<div class="app-shell">
    <!-- HEADER -->
    <header class="header">
        <div class="logo-circle">
            <span>SS</span>
        </div>
        <div class="header-text">
            <h1>SpySignal <span class="pill">stealth e2ee</span></h1>
            <div class="tagline">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π –º–µ—Å–µ–Ω–¥–∂–µ—Ä —ñ –¥–∑–≤—ñ–Ω–∫–∏</div>
        </div>
    </header>

    <!-- STATUS BAR -->
    <div class="status-bar">
        <div id="status-dot" class="status-dot"></div>
        <div>
            <span class="status-label" id="status-label">–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞‚Ä¶</span>
            <span class="status-url" id="status-url"></span>
        </div>
    </div>

    <!-- LOGIN -->
    <section class="card" id="login-card">
        <div class="card-title">
            <span>1 ¬∑ –Ü–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è –∞–≥–µ–Ω—Ç–∞</span>
            <span class="badge-e2ee">E2EE –∫–ª—é—á—ñ –≥–µ–Ω–µ—Ä—É—é—Ç—å—Å—è –ª–æ–∫–∞–ª—å–Ω–æ</span>
        </div>
        <div class="card-subtitle">
            –í–≤–µ–¥–∏ —Å–≤—ñ–π –ø–æ–∑–∏–≤–Ω–∏–π (–Ω—ñ–∫–Ω–µ–π–º). –í—ñ–Ω –ø–æ—Ç—Ä—ñ–±–µ–Ω —Ç—ñ–ª—å–∫–∏ –¥–ª—è –ø–æ—à—É–∫—É, –∫–ª—é—á—ñ —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è —É —Ç–≤–æ—î–º—É –ø—Ä–∏—Å—Ç—Ä–æ—ó.
        </div>

        <div class="field-label">–ü–æ–∑–∏–≤–Ω–∏–π (username)</div>
        <input id="username" class="input" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥, ShadowFox" autocomplete="off">

        <button class="btn" onclick="register()">
            üîì –£–≤—ñ–π—Ç–∏ –≤ SpySignal
        </button>

        <div class="hint" id="my-id-hint" style="display:none;"></div>
    </section>

    <!-- MAIN: SEARCH + CHAT -->
    <section class="two-blocks" id="main-blocks" style="display:none;">

        <!-- SEARCH -->
        <div class="card">
            <div class="card-title">
                <span>2 ¬∑ –ü–æ—à—É–∫ –∫–æ–Ω—Ç–∞–∫—Ç—É</span>
                <button class="btn-small btn-secondary" onclick="backToLogin()">–ó–º—ñ–Ω–∏—Ç–∏ –∞–≥–µ–Ω—Ç–∞</button>
            </div>
            <div class="card-subtitle">
                –í–≤–µ–¥–∏ ID –∞–±–æ –Ω—ñ–∫–Ω–µ–π–º —ñ–Ω—à–æ–≥–æ –∞–≥–µ–Ω—Ç–∞, –∑ —è–∫–∏–º —Ö–æ—á–µ—à –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π –∫–∞–Ω–∞–ª.
            </div>

            <div class="field-label">–ü–æ—à—É–∫ (ID –∞–±–æ username)</div>
            <input id="search" class="input" placeholder="–ü—Ä–∏–∫–ª–∞–¥: 2 –∞–±–æ NightOwl" oninput="searchUser()">

            <div class="search-results" id="result"></div>
        </div>

        <!-- CHAT + CALLS + FILES -->
        <div class="card" id="chat-card" style="opacity:0.5; pointer-events:none;">
            <div class="chat-header-row">
                <div>
                    <div class="chat-peer" id="chat-peer">
                        3 ¬∑ –ß–∞—Ç <span>(–æ–±–µ—Ä–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞)</span>
                    </div>
                    <div class="typing-indicator" id="typing-indicator"></div>
                </div>
                <div class="call-controls">
                    <button class="call-btn" onclick="startCall()">üìû Call</button>
                    <button class="call-btn danger" onclick="endCall()">‚õî End</button>
                </div>
            </div>

            <div class="call-status" id="call-status"></div>

            <div class="chat-window" id="chat"></div>

            <div class="chat-input-row">
                <div class="chat-input">
                    <button class="chat-attach-btn" onclick="document.getElementById('file-input').click()">üìé</button>
                    <input id="msg" class="input" placeholder="–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è‚Ä¶" oninput="onTyping()">
                </div>
                <button class="chat-send-btn" onclick="sendMessage()">
                    <span>‚û§</span>
                </button>
            </div>

            <div class="footer-hint">
                –í—Å—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, —Ñ–∞–π–ª–∏ —Ç–∞ –¥–∑–≤—ñ–Ω–∫–∏ —à–∏—Ñ—Ä—É—é—Ç—å—Å—è <strong>–Ω–∞ –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö</strong>. –°–µ—Ä–≤–µ—Ä –±–∞—á–∏—Ç—å —Ç—ñ–ª—å–∫–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ñ –¥–∞–Ω—ñ.
            </div>
        </div>

    </section>

    <div class="toast" id="toast"></div>

    <!-- –°—Ö–æ–≤–∞–Ω–∏–π —ñ–Ω–ø—É—Ç –¥–ª—è —Ñ–∞–π–ª—ñ–≤ -->
    <input type="file" id="file-input" style="display:none" onchange="sendEncryptedFile(event)">

    <!-- –ê—É–¥—ñ–æ –¥–ª—è –¥–∑–≤—ñ–Ω–∫–∞ -->
    <audio id="remote-audio" autoplay playsinline></audio>
</div>

<script>
    // ‚öôÔ∏è URL —Ç–≤–æ–≥–æ –±–µ–∫–µ–Ω–¥—É Railway
    const API_BASE = "https://talented-energy-production.up.railway.app";

    // ========= –ì–õ–û–ë–ê–õ–¨–ù–Ü –ó–ú–Ü–ù–ù–Ü =========
    let token = null;
    let myID = null;
    let myUsername = null;
    let peerID = null;
    let peerUsername = null;

    let lastMessagesCount = 0;
    let pollingInterval = null;
    let typingTimeout = null;

    // Forward secrecy: –º—ñ–Ω—è—î–º–æ –∫–ª—é—á—ñ —Ä–∞–∑ –≤ N –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
    const KEY_ROTATION_EVERY = 30;
    let sentMessagesSinceKeyRotate = 0;

    // E2EE –∫–ª—é—á—ñ
    let myPrivateKey = null;
    let myPublicJwk = null;
    const LOCAL_KEY_STORAGE = "spysignal_e2ee_keypair_v2_rotating";

    const encoder = new TextEncoder();
    const decoder = new TextDecoder();

    const statusDot = document.getElementById("status-dot");
    const statusLabel = document.getElementById("status-label");
    const statusUrl = document.getElementById("status-url");
    const toastEl = document.getElementById("toast");
    const callStatusEl = document.getElementById("call-status");

    statusUrl.textContent = API_BASE.replace("https://", "");

    // –§–∞–π–ª-–∫–µ—à –ø—ñ—Å–ª—è –¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è
    const fileCache = {};

    // ========= WebRTC –¥–∑–≤—ñ–Ω–∫–∏ =========
    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let isCalling = false;
    let isInCall = false;
    let callRole = null; // "caller" | "callee"
    let signalingPollInterval = null;

    // ========= –£–¢–ò–õ–Ü–¢–ò =========
    function showToast(msg, isError = false) {
        toastEl.textContent = msg;
        toastEl.className = "toast show" + (isError ? " toast-error" : "");
        setTimeout(() => {
            toastEl.classList.remove("show");
        }, 2500);
    }

    function bufToBase64(buf) {
        let bin = "";
        const bytes = new Uint8Array(buf);
        for (let b of bytes) bin += String.fromCharCode(b);
        return btoa(bin);
    }

    function base64ToBuf(b64) {
        const bin = atob(b64);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) {
            bytes[i] = bin.charCodeAt(i);
        }
        return bytes.buffer;
    }

    // ========= E2EE –ö–õ–Æ–ß–Ü (–∑ —Ä–æ—Ç–∞—Ü—ñ—î—é) =========
    async function generateAndStoreKeyPair() {
        const keyPair = await crypto.subtle.generateKey(
            { name: "ECDH", namedCurve: "P-256" },
            true,
            ["deriveKey", "deriveBits"]
        );

        const pubJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
        const privJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);

        myPrivateKey = keyPair.privateKey;
        myPublicJwk = pubJwk;

        localStorage.setItem(
            LOCAL_KEY_STORAGE,
            JSON.stringify({ publicJwk: pubJwk, privateJwk: privJwk })
        );
    }

    async function ensureKeyPair() {
        if (myPrivateKey && myPublicJwk) return;

        const raw = localStorage.getItem(LOCAL_KEY_STORAGE);
        if (raw) {
            try {
                const parsed = JSON.parse(raw);
                myPublicJwk = parsed.publicJwk;
                const privJwk = parsed.privateJwk;
                myPrivateKey = await crypto.subtle.importKey(
                    "jwk",
                    privJwk,
                    { name: "ECDH", namedCurve: "P-256" },
                    false,
                    ["deriveKey", "deriveBits"]
                );
                return;
            } catch (e) {
                console.warn("–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∫–ª—é—á–∞, –≥–µ–Ω–µ—Ä—É—î–º–æ –Ω–æ–≤–∏–π", e);
            }
        }

        await generateAndStoreKeyPair();
    }

    async function rotateKeyPairIfNeeded() {
        sentMessagesSinceKeyRotate++;
        if (sentMessagesSinceKeyRotate >= KEY_ROTATION_EVERY) {
            sentMessagesSinceKeyRotate = 0;
            await generateAndStoreKeyPair();

            // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–æ–≤–∏–π pubkey –Ω–∞ —Å–µ—Ä–≤–µ—Ä
            if (token) {
                try {
                    await fetch(`${API_BASE}/api/pubkey`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": "Bearer " + token
                        },
                        body: JSON.stringify({ pubkey: JSON.stringify(myPublicJwk) })
                    });
                    showToast("–û–Ω–æ–≤–ª–µ–Ω–æ E2EE –∫–ª—é—á (forward secrecy)");
                } catch (e) {
                    console.warn("–ù–µ –≤–¥–∞–ª–æ—Å—è –æ–Ω–æ–≤–∏—Ç–∏ pubkey –ø—ñ—Å–ª—è —Ä–æ—Ç–∞—Ü—ñ—ó", e);
                }
            }
        }
    }

    async function getAesKeyForPeer(peerPubJwk) {
        if (!myPrivateKey) {
            await ensureKeyPair();
        }
        const peerPubKey = await crypto.subtle.importKey(
            "jwk",
            peerPubJwk,
            { name: "ECDH", namedCurve: "P-256" },
            false,
            []
        );

        const aesKey = await crypto.subtle.deriveKey(
            { name: "ECDH", public: peerPubKey },
            myPrivateKey,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"]
        );
        return aesKey;
    }

    async function encryptForPeer(plaintext, peerPubJwk) {
        const key = await getAesKeyForPeer(peerPubJwk);
        const iv = crypto.getRandomValues(new Uint8Array(12));

        const ciphertextBuf = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            key,
            encoder.encode(plaintext)
        );

        return {
            iv: bufToBase64(iv.buffer),
            ciphertext: bufToBase64(ciphertextBuf),
        };
    }

    async function decryptFromPeer(ciphertextB64, ivB64, peerPubJwk) {
        const key = await getAesKeyForPeer(peerPubJwk);
        const ivBuf = base64ToBuf(ivB64);
        const ctBuf = base64ToBuf(ciphertextB64);

        const plainBuf = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: new Uint8Array(ivBuf) },
            key,
            ctBuf
        );
        return decoder.decode(plainBuf);
    }

    // ========= –ü–Ü–î–ö–õ–Æ–ß–ï–ù–ù–Ø –î–û –°–ï–†–í–ï–†–ê =========
    async function checkHealth() {
        try {
            const res = await fetch(`${API_BASE}/health`);
            if (!res.ok) throw new Error("bad status");
            const data = await res.json();
            if (data.status === "ok") {
                statusDot.classList.remove("offline");
                statusLabel.textContent = "–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ —Å–µ—Ä–≤–µ—Ä–∞";
            } else {
                statusDot.classList.add("offline");
                statusLabel.textContent = "–°–µ—Ä–≤–µ—Ä –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–æ";
            }
        } catch {
            statusDot.classList.add("offline");
            statusLabel.textContent = "–ù–µ–º–∞—î –∑–≤'—è–∑–∫—É –∑ –±–µ–∫–µ–Ω–¥–æ–º";
        }
    }

    checkHealth();
    setInterval(checkHealth, 8000);

    // ========= Telegram WebApp –∞–≤—Ç–æ-–ª–æ–≥—ñ–Ω =========
    (function tryTelegramInit() {
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                const tg = window.Telegram.WebApp;
                tg.expand();
                const u = tg.initDataUnsafe && tg.initDataUnsafe.user;
                if (u && u.username) {
                    document.getElementById("username").value = u.username;
                }
            }
        } catch (e) {
            console.warn("Telegram WebApp –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π –∞–±–æ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è", e);
        }
    })();

    // ========= –ê–í–¢–û–†–ï–Ñ–°–¢–†–ê–¶–Ü–Ø =========
    async function register() {
        let username = document.getElementById("username").value.trim();
        if (!username) {
            showToast("–í–≤–µ–¥–∏ –ø–æ–∑–∏–≤–Ω–∏–π (username)", true);
            return;
        }

        try {
            const res = await fetch(`${API_BASE}/api/users/register`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ username })
            });

            const data = await res.json();
            if (!res.ok || !data.token || !data.id) {
                console.error("–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó:", data);
                showToast("–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó", true);
                return;
            }

            token = data.token;
            myID = data.id;
            myUsername = data.username;

            await ensureKeyPair();

            await fetch(`${API_BASE}/api/pubkey`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({ pubkey: JSON.stringify(myPublicJwk) })
            });

            document.getElementById("login-card").style.display = "none";
            document.getElementById("main-blocks").style.display = "flex";

            const hint = document.getElementById("my-id-hint");
            hint.style.display = "block";
            hint.textContent = `–¢–≤—ñ–π ID –∞–≥–µ–Ω—Ç–∞: ${myID}. –ô–æ–≥–æ –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–¥–∞—Ç–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫—É –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –ø–æ—à—É–∫—É.`;

            showToast("–£—Å–ø—ñ—à–Ω–æ. –¢–≤—ñ–π ID: " + myID);

            // –°—Ç–∞—Ä—Ç—É—î–º–æ –æ–ø–∏—Ç—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å —Ç–∞ —Å–∏–≥–Ω–∞–ª—ñ–Ω–≥—É
            if (pollingInterval) clearInterval(pollingInterval);
            pollingInterval = setInterval(loadMessages, 2000);

            if (signalingPollInterval) clearInterval(signalingPollInterval);
            signalingPollInterval = setInterval(pollSignaling, 1500);

        } catch (e) {
            console.error(e);
            showToast("–ù–µ –≤–¥–∞–ª–æ—Å—å –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—å –¥–æ —Å–µ—Ä–≤–µ—Ä–∞", true);
        }
    }

    function backToLogin() {
        token = null;
        myID = null;
        peerID = null;
        myPrivateKey = null;
        myPublicJwk = null;

        if (pollingInterval) clearInterval(pollingInterval);
        if (signalingPollInterval) clearInterval(signalingPollInterval);

        document.getElementById("main-blocks").style.display = "none";
        document.getElementById("login-card").style.display = "block";
    }

    // ========= –ü–û–®–£–ö –ö–û–†–ò–°–¢–£–í–ê–ß–Ü–í =========
    async function searchUser() {
        const q = document.getElementById("search").value.trim();
        const resultEl = document.getElementById("result");
        if (!q) {
            resultEl.innerHTML = "";
            return;
        }

        try {
            const res = await fetch(`${API_BASE}/api/users/search?query=${encodeURIComponent(q)}`);
            const data = await res.json();
            const users = data.results || [];
            let html = "";

            if (users.length === 0) {
                html = `<div class="hint">–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.</div>`;
            } else {
                users.forEach(u => {
                    html += `
                        <div class="user-item" onclick="openChat(${u.id}, '${u.username}')">
                            <div class="user-name">${u.username}</div>
                            <div class="user-id">ID: ${u.id}</div>
                        </div>
                    `;
                });
            }
            resultEl.innerHTML = html;
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ –ø–æ—à—É–∫—É:", e);
            showToast("–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ—à—É–∫—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤", true);
        }
    }

    const peerPubKeyCache = {};

    async function fetchPeerPubKey(peerId) {
        if (peerPubKeyCache[peerId]) return peerPubKeyCache[peerId];

        const res = await fetch(`${API_BASE}/api/pubkey/${peerId}`);
        if (!res.ok) {
            throw new Error("–£ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ–º–∞—î E2EE –∫–ª—é—á–∞");
        }
        const data = await res.json();
        const jwk = JSON.parse(data.pubkey);
        peerPubKeyCache[peerId] = jwk;
        return jwk;
    }

    async function openChat(id, username) {
        peerID = id;
        peerUsername = username;

        const chatPeerEl = document.getElementById("chat-peer");
        chatPeerEl.innerHTML = `3 ¬∑ –ß–∞—Ç –∑ <span>${username}</span> (ID: ${id})`;

        const chatCard = document.getElementById("chat-card");
        chatCard.style.opacity = "1";
        chatCard.style.pointerEvents = "auto";

        lastMessagesCount = 0;
        await loadMessages();
    }

    // ========= –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø –ü–û–í–Ü–î–û–ú–õ–ï–ù–¨ =========
    async function loadMessages() {
        if (!peerID || !token) return;

        try {
            const res = await fetch(`${API_BASE}/api/messages?peer_id=${peerID}`, {
                headers: { "Authorization": "Bearer " + token }
            });
            const data = await res.json();
            const msgs = data.messages || [];
            const chatEl = document.getElementById("chat");

            const peerPubJwk = await fetchPeerPubKey(peerID);

            const isNew = msgs.length > lastMessagesCount;
            let html = "";

            for (const m of msgs) {
                const cls = (m.from_id === myID) ? "msg me" : "msg";
                let contentHtml = "";
                let metaText = "";

                let decryptedText = "[–Ω–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏]";
                try {
                    decryptedText = await decryptFromPeer(m.ciphertext, m.iv, peerPubJwk);
                } catch (e) {
                    console.warn("–ü–æ–º–∏–ª–∫–∞ –¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è", e);
                }

                if (m.msg_type === "file") {
                    try {
                        const fileObj = JSON.parse(decryptedText);
                        fileCache[m.id] = fileObj;
                        const sizeKb = fileObj.data
                            ? Math.round((base64ToBuf(fileObj.data).byteLength / 1024))
                            : 0;
                        contentHtml = `
                            <div class="msg-file">
                                <div class="msg-file-title">üìé –§–∞–π–ª: ${fileObj.filename || "–Ω–µ–≤—ñ–¥–æ–º–∏–π"}</div>
                                <div class="msg-file-meta">${fileObj.mimeType || "application/octet-stream"} ¬∑ ~${sizeKb} KB</div>
                                <button class="msg-file-btn" onclick="downloadFile(${m.id})">‚¨áÔ∏è –†–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏ —ñ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏</button>
                            </div>
                        `;
                    } catch (e) {
                        console.warn("–ü–æ–º–∏–ª–∫–∞ –ø–∞—Ä—Å—É —Ñ–∞–π–ª—É", e);
                        contentHtml = `<div>${decryptedText}</div>`;
                    }
                } else {
                    contentHtml = `<div>${decryptedText}</div>`;
                }

                const date = new Date(m.created_at);
                const hh = String(date.getHours()).padStart(2, "0");
                const mm = String(date.getMinutes()).padStart(2, "0");
                metaText = `${hh}:${mm}`;

                html += `
                    <div class="${cls}">
                        ${contentHtml}
                        <div class="msg-meta">${metaText}</div>
                    </div>
                `;
            }

            chatEl.innerHTML = html;
            chatEl.scrollTop = chatEl.scrollHeight;

            if (isNew && navigator.vibrate) {
                navigator.vibrate(40);
            }

            lastMessagesCount = msgs.length;
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å:", e);
        }
    }

    // ========= –¢–ê–ô–ü–Ü–ù–ì =========
    function onTyping() {
        const typingEl = document.getElementById("typing-indicator");
        typingEl.textContent = "–¢–∏ –¥—Ä—É–∫—É—î—à‚Ä¶";

        if (typingTimeout) clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            typingEl.textContent = "";
        }, 1200);
    }

    // ========= –ù–ê–î–°–ò–õ–ê–ù–ù–Ø –¢–ï–ö–°–¢–û–í–û–ì–û –ü–û–í–Ü–î–û–ú–õ–ï–ù–ù–Ø =========
    async function sendMessage() {
        const input = document.getElementById("msg");
        const msg = input.value.trim();
        if (!msg || !peerID) return;

        try {
            const peerPubJwk = await fetchPeerPubKey(peerID);
            const { iv, ciphertext } = await encryptForPeer(msg, peerPubJwk);

            await fetch(`${API_BASE}/api/messages`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({
                    to: peerID,
                    iv: iv,
                    ciphertext: ciphertext,
                    msg_type: "text"
                })
            });

            input.value = "";
            await loadMessages();
            await rotateKeyPairIfNeeded();
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è:", e);
            showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (E2EE)", true);
        }
    }

    // ========= –ù–ê–î–°–ò–õ–ê–ù–ù–Ø –®–ò–§–†–û–í–ê–ù–û–ì–û –§–ê–ô–õ–£ =========
    async function sendEncryptedFile(event) {
        if (!peerID) {
            showToast("–°–ø–æ—á–∞—Ç–∫—É –æ–±–µ—Ä–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞", true);
            event.target.value = "";
            return;
        }
        const file = event.target.files[0];
        if (!file) return;

        try {
            const arrayBuf = await file.arrayBuffer();
            const dataB64 = bufToBase64(arrayBuf);

            const payload = {
                filename: file.name,
                mimeType: file.type || "application/octet-stream",
                data: dataB64
            };

            const peerPubJwk = await fetchPeerPubKey(peerID);
            const { iv, ciphertext } = await encryptForPeer(JSON.stringify(payload), peerPubJwk);

            await fetch(`${API_BASE}/api/messages`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({
                    to: peerID,
                    iv: iv,
                    ciphertext: ciphertext,
                    msg_type: "file"
                })
            });

            showToast("–§–∞–π–ª –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ)");
            await loadMessages();
            await rotateKeyPairIfNeeded();
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª—É:", e);
            showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ñ–∞–π–ª", true);
        } finally {
            event.target.value = "";
        }
    }

    function downloadFile(messageId) {
        const meta = fileCache[messageId];
        if (!meta || !meta.data) {
            showToast("–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö –¥–ª—è —Ñ–∞–π–ª—É", true);
            return;
        }
        try {
            const buf = base64ToBuf(meta.data);
            const blob = new Blob([buf], { type: meta.mimeType || "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = meta.filename || "file.bin";
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É", e);
            showToast("–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—ñ —Ñ–∞–π–ª—É", true);
        }
    }

    // ========= WEBRTC –î–ó–í–Ü–ù–ö–ò (—á–µ—Ä–µ–∑ –±–µ–∫–µ–Ω–¥-—Å–∏–≥–Ω–∞–ª—ñ–Ω–≥) =========
    function updateCallStatus(text) {
        callStatusEl.textContent = text || "";
    }

    async function createPeerConnection() {
        if (!("RTCPeerConnection" in window)) {
            showToast("–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î WebRTC", true);
            return null;
        }

        const config = {
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" }
            ]
        };

        pc = new RTCPeerConnection(config);

        pc.onicecandidate = async (event) => {
            if (event.candidate && peerID && token) {
                try {
                    await fetch(`${API_BASE}/call/candidate`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": "Bearer " + token
                        },
                        body: JSON.stringify({
                            to: peerID,
                            candidate: event.candidate
                        })
                    });
                } catch (e) {
                    console.warn("–ü–æ–º–∏–ª–∫–∞ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è ICE candidate", e);
                }
            }
        };

        remoteStream = new MediaStream();
        const remoteAudio = document.getElementById("remote-audio");
        remoteAudio.srcObject = remoteStream;

        pc.ontrack = (event) => {
            event.streams[0].getTracks().forEach(t => remoteStream.addTrack(t));
        };

        if (!localStream) {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            } catch (e) {
                console.error("Mic error", e);
                showToast("–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞", true);
                return null;
            }
        }

        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
        });

        return pc;
    }

    async function startCall() {
        if (!peerID) {
            showToast("–°–ø–æ—á–∞—Ç–∫—É –æ–±–µ—Ä–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞", true);
            return;
        }
        if (isInCall || isCalling) {
            showToast("–î–∑–≤—ñ–Ω–æ–∫ –≤–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π", true);
            return;
        }

        try {
            const conn = await createPeerConnection();
            if (!conn) return;

            callRole = "caller";
            isCalling = true;
            updateCallStatus("üìû –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–∑–≤—ñ–Ω–∫–∞‚Ä¶");

            const offer = await conn.createOffer();
            await conn.setLocalDescription(offer);

            await fetch(`${API_BASE}/call/offer`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({
                    to: peerID,
                    sdp: offer.sdp
                })
            });

            updateCallStatus("üì° –û—á—ñ–∫—É—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –≤—ñ–¥ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞‚Ä¶");
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ startCall", e);
            showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ—á–∞—Ç–∏ –¥–∑–≤—ñ–Ω–æ–∫", true);
            cleanupCall();
        }
    }

    async function handleIncomingOffer(fromId, sdp) {
        if (isInCall || isCalling) {
            // –ú–æ–∂–Ω–∞ —ñ–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ –∞–±–æ –¥–æ–¥–∞—Ç–∏ "busy"
            return;
        }
        peerID = fromId;
        callRole = "callee";

        const chatPeerEl = document.getElementById("chat-peer");
        chatPeerEl.innerHTML = `3 ¬∑ –ß–∞—Ç –∑ <span>ID ${fromId}</span> (–¥–∑–≤—ñ–Ω–æ–∫)`;

        if (!confirm(`–í—Ö—ñ–¥–Ω–∏–π –¥–∑–≤—ñ–Ω–æ–∫ –≤—ñ–¥ –∞–≥–µ–Ω—Ç–∞ ${fromId}. –ü—Ä–∏–π–Ω—è—Ç–∏?`)) {
            // –æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ: —Å–∫–∞–∑–∞—Ç–∏ –±–µ–∫–µ–Ω–¥—É "reject"
            return;
        }

        try {
            const conn = await createPeerConnection();
            if (!conn) return;

            updateCallStatus("üîî –í—Ö—ñ–¥–Ω–∏–π –¥–∑–≤—ñ–Ω–æ–∫ ‚Äî –∑ º—î–¥–Ω–∞–Ω–Ω—è‚Ä¶");

            await conn.setRemoteDescription(new RTCSessionDescription({
                type: "offer",
                sdp: sdp
            }));

            const answer = await conn.createAnswer();
            await conn.setLocalDescription(answer);

            await fetch(`${API_BASE}/call/answer`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + token
                },
                body: JSON.stringify({
                    to: fromId,
                    sdp: answer.sdp
                })
            });

            isInCall = true;
            updateCallStatus("‚úÖ –î–∑–≤—ñ–Ω–æ–∫ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ handleIncomingOffer", e);
            showToast("–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –ø—Ä–∏–π–æ–º—É –¥–∑–≤—ñ–Ω–∫–∞", true);
            cleanupCall();
        }
    }

    async function handleIncomingAnswer(fromId, sdp) {
        if (!pc || callRole !== "caller" || !isCalling) return;

        try {
            await pc.setRemoteDescription(new RTCSessionDescription({
                type: "answer",
                sdp: sdp
            }));
            isCalling = false;
            isInCall = true;
            updateCallStatus("‚úÖ –î–∑–≤—ñ–Ω–æ–∫ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
        } catch (e) {
            console.error("–ü–æ–º–∏–ª–∫–∞ handleIncomingAnswer", e);
            showToast("–ü–æ–º–∏–ª–∫–∞ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è answer", true);
        }
    }

    async function handleIncomingCandidates(candidates) {
        if (!pc) return;
        for (const c of candidates) {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(c.candidate));
            } catch (e) {
                console.warn("–ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è ICE candidate", e);
            }
        }
    }

    function cleanupCall() {
        if (pc) {
            pc.onicecandidate = null;
            pc.ontrack = null;
            pc.close();
            pc = null;
        }
        isCalling = false;
        isInCall = false;
        callRole = null;
        updateCallStatus("");
    }

    function endCall() {
        cleanupCall();
        showToast("–î–∑–≤—ñ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–æ");
    }

    // –û–ø–∏—Ç—É–≤–∞–Ω–Ω—è —Å–∏–≥–Ω–∞–ª—ñ–Ω–≥—É
    async function pollSignaling() {
        if (!token || !myID) return;

        try {
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –Ω–æ–≤–∏–π offer –¥–ª—è –Ω–∞—Å
            if (!isInCall && !isCalling) {
                const resOffer = await fetch(`${API_BASE}/call/offer?peer_id=${myID}`, {
                    headers: { "Authorization": "Bearer " + token }
                });
                if (resOffer.status === 200) {
                    const dataOffer = await resOffer.json(); // {from_id, sdp}
                    if (dataOffer && dataOffer.from_id && dataOffer.sdp) {
                        await handleIncomingOffer(dataOffer.from_id, dataOffer.sdp);
                    }
                }
            }

            // –Ø–∫—â–æ –º–∏ caller ‚Äî —á–µ–∫–∞—î–º–æ answer
            if (callRole === "caller" && isCalling) {
                const resAnswer = await fetch(`${API_BASE}/call/answer?peer_id=${myID}`, {
                    headers: { "Authorization": "Bearer " + token }
                });
                if (resAnswer.status === 200) {
                    const dataAnswer = await resAnswer.json(); // {from_id, sdp}
                    if (dataAnswer && dataAnswer.from_id && dataAnswer.sdp) {
                        await handleIncomingAnswer(dataAnswer.from_id, dataAnswer.sdp);
                    }
                }
            }

            // ICE candidates
            const resCand = await fetch(`${API_BASE}/call/candidate?peer_id=${myID}`, {
                headers: { "Authorization": "Bearer " + token }
            });
            if (resCand.status === 200) {
                const dataCand = await resCand.json(); // {candidates: [{from_id, candidate}, ...]}
                if (dataCand && Array.isArray(dataCand.candidates) && dataCand.candidates.length > 0) {
                    await handleIncomingCandidates(dataCand.candidates);
                }
            }
        } catch (e) {
            console.warn("–ü–æ–º–∏–ª–∫–∞ —Å–∏–≥–Ω–∞–ª—ñ–Ω–≥—É", e);
        }
    }
</script>
</body>
</html>
