<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>SpySignal ‚Äî E2EE Chat + Files + Calls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!--
    ‚öôÔ∏è –û—á—ñ–∫—É–≤–∞–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–µ–∫–µ–Ω–¥—É:

    ROOT:
      GET  /health

    API (–ø—Ä–µ—Ñ—ñ–∫—Å /api):
      POST /api/users/register         {username} => {id, username, token}
      GET  /api/users/search?query=...
      POST /api/users/pubkey           {pubkey: json-string}
      GET  /api/users/pubkey/{user_id}

      GET  /api/messages?peer_id=...
      POST /api/messages
          {to, iv, ciphertext, msg_type: "text"|"file", file_id?}

      POST /api/files/upload   (multipart/form-data)
          fields: file, to, iv

      GET  /api/files/{file_id}   (encrypted blob)

      POST /api/call/offer      {to, sdp}
      POST /api/call/answer     {to, sdp}
      POST /api/call/candidate  {to, candidate}
      GET  /api/call/poll?user_id=ME&since_id=LAST
          => {events:[{id, type:"offer"|"answer"|"candidate", from_id, sdp?, candidate?}]}
  -->

  <style>
    :root {
      --bg: #05070c;
      --bg-alt: #0c1018;
      --card: #121826;
      --accent: #3d7bfd;
      --accent-soft: rgba(61, 123, 253, 0.15);
      --danger: #ff4d4d;
      --text: #ffffff;
      --text-muted: #8a93a5;
      --border: #1f2433;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #182744 0, #05070c 55%);
      color: var(--text);
    }

    .app-shell {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px 4px;
    }

    .logo-circle {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: 1px solid var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 12px rgba(0, 255, 180, 0.35);
      background: radial-gradient(circle at 30% 20%, #26ffe0 0, #060811 55%);
    }

    .logo-circle span {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .header-text h1 {
      font-size: 18px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tagline {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .pill {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(61, 123, 253, 0.4);
      background: rgba(8, 15, 32, 0.9);
      text-transform: uppercase;
      letter-spacing: .06em;
    }

    .status-bar {
      margin: 6px 4px 8px;
      padding: 7px 10px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      font-size: 11px;
      background: rgba(3, 10, 25, 0.9);
      border: 1px solid var(--border);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      box-shadow: 0 0 10px rgba(77, 255, 153, 0.8);
      background: radial-gradient(circle, #81ffb7 0, #08c96a 60%);
    }

    .status-dot.offline {
      background: radial-gradient(circle, #ff9b9b 0, #ff4040 60%);
      box-shadow: 0 0 8px rgba(255, 64, 64, 0.8);
    }

    .status-label {
      font-weight: 500;
      margin-right: 4px;
    }

    .status-url {
      color: var(--text-muted);
      opacity: .8;
    }

    .card {
      background: rgba(11, 15, 27, 0.96);
      border-radius: 16px;
      padding: 14px;
      border: 1px solid var(--border);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
      margin-bottom: 10px;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .card-subtitle {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .field-label {
      font-size: 11px;
      color: var(--text-muted);
      margin: 6px 2px 2px;
    }

    .input {
      width: 100%;
      padding: 9px 11px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #060a13;
      color: var(--text);
      font-size: 14px;
      outline: none;
    }

    .input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(61, 123, 253, 0.6);
    }

    .btn {
      width: 100%;
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      background: linear-gradient(135deg, #3d7bfd, #47d3ff);
      color: #fff;
      margin-top: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .btn:active {
      transform: translateY(1px);
      filter: brightness(.95);
    }

    .btn-secondary {
      background: rgba(7, 12, 26, 0.9);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-small {
      width: auto;
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 999px;
    }

    .hint {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .two-blocks {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .search-results {
      max-height: 160px;
      overflow-y: auto;
      margin-top: 6px;
    }

    .user-item {
      background: #0c1018;
      border-radius: 10px;
      padding: 8px 9px;
      margin-bottom: 6px;
      border: 1px solid rgba(54, 63, 90, 0.8);
      cursor: pointer;
      display: flex;
      flex-direction: column;
    }

    .user-item:hover {
      border-color: var(--accent);
      background: rgba(14, 20, 37, 0.95);
    }

    .user-name {
      font-size: 13px;
      font-weight: 500;
    }

    .user-id {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 1px;
    }

    .chat-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 4px;
    }

    .chat-peer {
      font-size: 13px;
      font-weight: 500;
    }

    .chat-peer span {
      color: var(--accent);
    }

    .typing-indicator {
      font-size: 11px;
      color: var(--text-muted);
      min-height: 14px;
    }

    .chat-window {
      border-radius: 12px;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, rgba(61, 123, 253, .08) 0, #05070c 40%);
      height: 270px;
      padding: 8px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .msg {
      padding: 7px 10px;
      border-radius: 11px;
      font-size: 13px;
      max-width: 78%;
      line-height: 1.4;
      background: #171f32;
      animation: fadeUp .18s ease-out forwards;
      opacity: 0;
      transform: translateY(4px);
      word-wrap: break-word;
    }

    .msg.me {
      margin-left: auto;
      background: linear-gradient(135deg, #3d7bfd, #40c3ff);
    }

    .msg-meta {
      font-size: 9px;
      color: #b8c2d8;
      margin-top: 2px;
    }

    .msg-file-link {
      font-size: 12px;
      text-decoration: underline;
      cursor: pointer;
    }

    @keyframes fadeUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .chat-input-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
    }

    .chat-input {
      flex: 1;
    }

    .chat-send-btn {
      width: 44px;
      height: 38px;
      border-radius: 12px;
      background: var(--accent);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .chat-send-btn span {
      font-size: 18px;
    }

    .file-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
    }

    .file-name {
      font-size: 11px;
      color: var(--text-muted);
      max-width: 220px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .footer-hint {
      margin-top: 6px;
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
    }

    .footer-hint strong {
      color: #61ffa8;
    }

    .badge-e2ee {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(140, 255, 195, 0.8);
      background: rgba(9, 24, 20, 0.9);
      color: #9dffd0;
      display: inline-flex;
      align-items: center;
      gap: 3px;
    }

    .toast {
      position: fixed;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      background: #141a28;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 7px 14px;
      font-size: 12px;
      display: none;
      align-items: center;
      gap: 6px;
      z-index: 999;
    }

    .toast.show {
      display: inline-flex;
      animation: fadeToast .25s ease-out;
    }

    .toast-error {
      border-color: rgba(255, 85, 85, 0.6);
      color: #ffb3b3;
    }

    @keyframes fadeToast {
      from {
        opacity: 0;
        transform: translate(-50%, 4px);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }

    /* Call UI */
    .call-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    .call-status {
      font-size: 11px;
      color: var(--text-muted);
    }

    .btn-call {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #20c997, #02b3ff);
      color: #fff;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .btn-call.end {
      background: linear-gradient(135deg, #ff4d4d, #ff7b7b);
    }

    audio {
      display: none;
    }
  </style>
</head>

<body>
<div class="app-shell">
  <header class="header">
    <div class="logo-circle">
      <span>SS</span>
    </div>
    <div class="header-text">
      <h1>SpySignal <span class="pill">E2EE</span></h1>
      <div class="tagline">–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π —á–∞—Ç, —Ñ–∞–π–ª–∏ —Ç–∞ –¥–∑–≤—ñ–Ω–∫–∏</div>
    </div>
  </header>

  <div class="status-bar">
    <div id="status-dot" class="status-dot"></div>
    <div>
      <span class="status-label" id="status-label">–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞‚Ä¶</span>
      <span class="status-url" id="status-url"></span>
    </div>
  </div>

  <!-- LOGIN / REGISTER -->
  <section class="card" id="login-card">
    <div class="card-title">
      <span>1 ¬∑ –Ü–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è –∞–≥–µ–Ω—Ç–∞</span>
      <span class="badge-e2ee">E2EE –∫–ª—é—á—ñ –≥–µ–Ω–µ—Ä—É—é—Ç—å—Å—è –ª–æ–∫–∞–ª—å–Ω–æ</span>
    </div>
    <div class="card-subtitle">
      –í–≤–µ–¥–∏ —Å–≤—ñ–π –ø–æ–∑–∏–≤–Ω–∏–π. –°–µ—Ä–≤–µ—Ä –±–∞—á–∏—Ç—å —Ç—ñ–ª—å–∫–∏ —Ç–æ–∫–µ–Ω, –∫–ª—é—á—ñ —Ç–∞ –ø–µ—Ä–µ–ø–∏—Å–∫–∞ —à–∏—Ñ—Ä—É—é—Ç—å—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä—ñ.
    </div>

    <div class="field-label">–ü–æ–∑–∏–≤–Ω–∏–π (username)</div>
    <input id="username" class="input" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥, ShadowFox" autocomplete="off">

    <button class="btn" onclick="registerUser()">
      üîì –£–≤—ñ–π—Ç–∏ –≤ SpySignal
    </button>

    <div class="hint" id="my-id-hint" style="display:none;"></div>
  </section>

  <!-- MAIN BLOCKS -->
  <section class="two-blocks" id="main-blocks" style="display:none;">

    <!-- SEARCH BLOCK -->
    <div class="card">
      <div class="card-title">
        <span>2 ¬∑ –ü–æ—à—É–∫ –∫–æ–Ω—Ç–∞–∫—Ç—É</span>
        <button class="btn-small btn-secondary" onclick="backToLogin()">–ó–º—ñ–Ω–∏—Ç–∏ –∞–≥–µ–Ω—Ç–∞</button>
      </div>
      <div class="card-subtitle">
        –í–≤–µ–¥–∏ ID –∞–±–æ –Ω—ñ–∫–Ω–µ–π–º –∞–≥–µ–Ω—Ç–∞, –∑ —è–∫–∏–º —Ö–æ—á–µ—à —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π –∫–∞–Ω–∞–ª.
      </div>

      <div class="field-label">–ü–æ—à—É–∫ (ID –∞–±–æ username)</div>
      <input id="search" class="input" placeholder="–ü—Ä–∏–∫–ª–∞–¥: 2 –∞–±–æ NightOwl" oninput="searchUser()">

      <div class="search-results" id="result"></div>
    </div>

    <!-- CHAT / FILES / CALLS -->
    <div class="card" id="chat-card" style="opacity:0.5; pointer-events:none;">
      <div class="chat-header-row">
        <div class="chat-peer" id="chat-peer">
          3 ¬∑ –ß–∞—Ç <span>(–æ–±–µ—Ä–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞)</span>
        </div>
        <div class="typing-indicator" id="typing-indicator"></div>
      </div>

      <div class="chat-window" id="chat"></div>

      <div class="chat-input-row">
        <div class="chat-input">
          <input id="msg" class="input" placeholder="–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è‚Ä¶" oninput="onTyping()">
        </div>
        <button class="chat-send-btn" onclick="sendMessage()">
          <span>‚û§</span>
        </button>
      </div>

      <div class="file-row">
        <input type="file" id="file-input">
        <button class="btn-small btn-secondary" onclick="sendFile()">üìé –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ñ–∞–π–ª (E2EE)</button>
      </div>

      <div class="call-row">
        <button class="btn-call" id="btn-call" onclick="toggleCall()">üìû Call</button>
        <span class="call-status" id="call-status">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è‚Ä¶</span>
      </div>

      <div class="footer-hint">
        –í—Å—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, —Ñ–∞–π–ª–∏ —Ç–∞ –º–µ–¥—ñ–∞ —à–∏—Ñ—Ä—É—é—Ç—å—Å—è <strong>–Ω–∞ –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö</strong>, —Å–µ—Ä–≤–µ—Ä –±–∞—á–∏—Ç—å —Ç—ñ–ª—å–∫–∏ —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç.
      </div>
    </div>

  </section>

  <div class="toast" id="toast"></div>

  <!-- –ê—É–¥—ñ–æ –¥–ª—è –¥–∑–≤—ñ–Ω–∫—ñ–≤ -->
  <audio id="local-audio" autoplay muted></audio>
  <audio id="remote-audio" autoplay></audio>
</div>

<script>
  // ==== –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø API ====
  const API_ROOT = "https://talented-energy-production.up.railway.app"; // ‚¨Ö‚¨Ö‚¨Ö –ó–ê–ú–Ü–ù–ò –ù–ê –°–í–Ü–ô –î–û–ú–ï–ù
  const API_BASE = API_ROOT + "/api";

  // ==== –ì–õ–û–ë–ê–õ–¨–ù–Ü –°–¢–ê–ù–ò ====
  let token = null;
  let myID = null;
  let myUsername = null;
  let peerID = null;
  let peerUsername = null;

  let lastMessagesCount = 0;
  let pollingInterval = null;
  let pollCallsInterval = null;
  let typingTimeout = null;

  // E2EE
  let myPrivateKey = null;
  let myPublicJwk = null;
  const LOCAL_KEY_STORAGE = "spysignal_e2ee_keypair_v1";
  const KEY_ROTATE_MS = 30 * 60 * 1000; // 30 —Ö–≤–∏–ª–∏–Ω
  let lastKeyGenTime = 0;

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  // WebRTC
  let pc = null;
  let currentCallPeerId = null;
  let lastCallEventId = 0;
  let localStream = null;

  // DOM
  const statusDot = document.getElementById("status-dot");
  const statusLabel = document.getElementById("status-label");
  const statusUrl = document.getElementById("status-url");
  const toastEl = document.getElementById("toast");
  const localAudio = document.getElementById("local-audio");
  const remoteAudio = document.getElementById("remote-audio");

  statusUrl.textContent = API_ROOT.replace(/^https?:\/\//, "");

  function showToast(msg, isError = false) {
    toastEl.textContent = msg;
    toastEl.className = "toast show" + (isError ? " toast-error" : "");
    setTimeout(() => {
      toastEl.classList.remove("show");
    }, 2500);
  }

  function bufToBase64(buf) {
    let bin = "";
    const bytes = new Uint8Array(buf);
    for (let b of bytes) bin += String.fromCharCode(b);
    return btoa(bin);
  }

  function base64ToBuf(b64) {
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) {
      bytes[i] = bin.charCodeAt(i);
    }
    return bytes.buffer;
  }

  async function ensureKeyPair(forceRotate = false) {
    const now = Date.now();
    if (!forceRotate && myPrivateKey && myPublicJwk && now - lastKeyGenTime < KEY_ROTATE_MS) {
      return;
    }

    const raw = localStorage.getItem(LOCAL_KEY_STORAGE);
    if (!forceRotate && raw) {
      try {
        const parsed = JSON.parse(raw);
        myPublicJwk = parsed.publicJwk;
        const privJwk = parsed.privateJwk;
        myPrivateKey = await crypto.subtle.importKey(
          "jwk",
          privJwk,
          { name: "ECDH", namedCurve: "P-256" },
          false,
          ["deriveKey", "deriveBits"]
        );
        lastKeyGenTime = now;
        return;
      } catch (e) {
        console.warn("–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∫–ª—é—á–∞, –≥–µ–Ω–µ—Ä—É—î–º–æ –Ω–æ–≤–∏–π", e);
      }
    }

    const keyPair = await crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: "P-256" },
      true,
      ["deriveKey", "deriveBits"]
    );

    const pubJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
    const privJwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);

    myPrivateKey = keyPair.privateKey;
    myPublicJwk = pubJwk;
    lastKeyGenTime = now;

    localStorage.setItem(LOCAL_KEY_STORAGE,
      JSON.stringify({ publicJwk: pubJwk, privateJwk: privJwk })
    );

    if (token) {
      try {
        await fetch(`${API_BASE}/users/pubkey`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + token
          },
          body: JSON.stringify({ pubkey: JSON.stringify(myPublicJwk) })
        });
      } catch (e) {
        console.warn("–ù–µ –≤–¥–∞–ª–æ—Å—å –æ–Ω–æ–≤–∏—Ç–∏ –ø—É–±–ª—ñ—á–Ω–∏–π –∫–ª—é—á –Ω–∞ —Å–µ—Ä–≤–µ—Ä—ñ", e);
      }
    }
  }

  async function rotateKeyPair() {
    await ensureKeyPair(true);
    showToast("–ö—Ä–∏–ø—Ç–æ–∫–ª—é—á –æ–Ω–æ–≤–ª–µ–Ω–æ (forward secrecy)");
  }

  const peerPubKeyCache = {};

  async function fetchPeerPubKey(peerId) {
    if (peerPubKeyCache[peerId]) return peerPubKeyCache[peerId];

    const res = await fetch(`${API_BASE}/users/pubkey/${peerId}`);
    if (!res.ok) {
      throw new Error("–£ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ–º–∞—î E2EE –∫–ª—é—á–∞");
    }
    const data = await res.json();
    const jwk = JSON.parse(data.pubkey);
    peerPubKeyCache[peerId] = jwk;
    return jwk;
  }

  async function getAesKeyForPeer(peerPubJwk) {
    await ensureKeyPair();
    const peerPubKey = await crypto.subtle.importKey(
      "jwk",
      peerPubJwk,
      { name: "ECDH", namedCurve: "P-256" },
      false,
      []
    );

    const aesKey = await crypto.subtle.deriveKey(
      { name: "ECDH", public: peerPubKey },
      myPrivateKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    return aesKey;
  }

  async function encryptTextForPeer(plaintext, peerPubJwk) {
    const key = await getAesKeyForPeer(peerPubJwk);
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const ciphertextBuf = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(plaintext)
    );

    return {
      iv: bufToBase64(iv.buffer),
      ciphertext: bufToBase64(ciphertextBuf),
    };
  }

  async function encryptBytesForPeer(bytesArrayBuffer, peerPubJwk) {
    const key = await getAesKeyForPeer(peerPubJwk);
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const ciphertextBuf = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      bytesArrayBuffer
    );

    return {
      iv: bufToBase64(iv.buffer),
      ciphertext: bufToBase64(ciphertextBuf),
    };
  }

  async function decryptFromPeer(ciphertextB64, ivB64, peerPubJwk) {
    const key = await getAesKeyForPeer(peerPubJwk);
    const ivBuf = base64ToBuf(ivB64);
    const ctBuf = base64ToBuf(ciphertextB64);

    const plainBuf = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: new Uint8Array(ivBuf) },
      key,
      ctBuf
    );
    return decoder.decode(plainBuf);
  }

  async function decryptBytesFromPeer(ciphertextArrayBuffer, ivB64, peerPubJwk) {
    const key = await getAesKeyForPeer(peerPubJwk);
    const ivBuf = base64ToBuf(ivB64);

    const plainBuf = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: new Uint8Array(ivBuf) },
      key,
      ciphertextArrayBuffer
    );
    return plainBuf;
  }

  // ==== HEALTH CHECK ====
  async function checkHealth() {
    try {
      const res = await fetch(`${API_ROOT}/health`);
      if (!res.ok) throw new Error("bad status");
      const data = await res.json();
      if (data.status === "ok") {
        statusDot.classList.remove("offline");
        statusLabel.textContent = "–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ —Å–µ—Ä–≤–µ—Ä–∞";
      } else {
        statusDot.classList.add("offline");
        statusLabel.textContent = "–°–µ—Ä–≤–µ—Ä –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î –Ω–µ–∫–æ—Ä–µ–∫—Ç–Ω–æ";
      }
    } catch {
      statusDot.classList.add("offline");
      statusLabel.textContent = "–ù–µ–º–∞—î –∑–≤'—è–∑–∫—É –∑ –±–µ–∫–µ–Ω–¥–æ–º";
    }
  }

  checkHealth();
  setInterval(checkHealth, 8000);

  // ==== Telegram WebApp –∞–≤—Ç–æ–∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è ====
  (function tryTelegramInit() {
    try {
      if (window.Telegram && window.Telegram.WebApp) {
        const tg = window.Telegram.WebApp;
        tg.expand();
        const u = tg.initDataUnsafe && tg.initDataUnsafe.user;
        if (u && u.username) {
          document.getElementById("username").value = u.username;
        }
      }
    } catch (e) {
      console.warn("Telegram WebApp –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π –∞–±–æ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è", e);
    }
  })();

  // ==== AUTH ====
  async function registerUser() {
    let username = document.getElementById("username").value.trim();
    if (!username) {
      showToast("–í–≤–µ–¥–∏ –ø–æ–∑–∏–≤–Ω–∏–π (username)", true);
      return;
    }

    try {
      const res = await fetch(`${API_BASE}/users/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username })
      });

      const data = await res.json();
      if (!res.ok || !data.token || !data.id) {
        console.error("–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó:", data);
        showToast("–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó", true);
        return;
      }

      token = data.token;
      myID = data.id;
      myUsername = data.username;

      await ensureKeyPair(true); // –æ–¥—Ä–∞–∑—É –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –∫–ª—é—á—ñ —Ç–∞ –∑–∞–ª–∏—Ç–∏ –ø—É–±–ª—ñ—á–Ω–∏–π

      document.getElementById("login-card").style.display = "none";
      document.getElementById("main-blocks").style.display = "flex";

      const hint = document.getElementById("my-id-hint");
      hint.style.display = "block";
      hint.textContent = `–¢–≤—ñ–π ID –∞–≥–µ–Ω—Ç–∞: ${myID}. –ü–µ—Ä–µ–¥–∞–π –π–æ–≥–æ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫—É –¥–ª—è –ø–æ—à—É–∫—É.`;

      showToast("–£—Å–ø—ñ—à–Ω–æ. –¢–≤—ñ–π ID: " + myID);

      if (pollCallsInterval) clearInterval(pollCallsInterval);
      pollCallsInterval = setInterval(pollCallEvents, 2000);
    } catch (e) {
      console.error(e);
      showToast("–ù–µ –≤–¥–∞–ª–æ—Å—å –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—å –¥–æ —Å–µ—Ä–≤–µ—Ä–∞", true);
    }
  }

  function backToLogin() {
    token = null;
    myID = null;
    peerID = null;
    peerUsername = null;

    document.getElementById("main-blocks").style.display = "none";
    document.getElementById("login-card").style.display = "block";
  }

  // ==== SEARCH ====
  async function searchUser() {
    const q = document.getElementById("search").value.trim();
    const resultEl = document.getElementById("result");
    if (!q) {
      resultEl.innerHTML = "";
      return;
    }

    try {
      const res = await fetch(`${API_BASE}/users/search?query=${encodeURIComponent(q)}`, {
        headers: token ? { "Authorization": "Bearer " + token } : {}
      });
      const data = await res.json();
      const users = data.results || [];
      let html = "";

      if (users.length === 0) {
        html = `<div class="hint">–ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.</div>`;
      } else {
        users.forEach(u => {
          html += `
            <div class="user-item" onclick="openChat(${u.id}, '${u.username}')">
              <div class="user-name">${u.username}</div>
              <div class="user-id">ID: ${u.id}</div>
            </div>
          `;
        });
      }
      resultEl.innerHTML = html;
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ –ø–æ—à—É–∫—É:", e);
      showToast("–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ—à—É–∫—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤", true);
    }
  }

  // ==== CHAT ====
  async function openChat(id, username) {
    peerID = id;
    peerUsername = username;

    const chatPeerEl = document.getElementById("chat-peer");
    chatPeerEl.innerHTML = `3 ¬∑ –ß–∞—Ç –∑ <span>${username}</span> (ID: ${id})`;

    const chatCard = document.getElementById("chat-card");
    chatCard.style.opacity = "1";
    chatCard.style.pointerEvents = "auto";

    lastMessagesCount = 0;
    await loadMessages();

    if (pollingInterval) clearInterval(pollingInterval);
    pollingInterval = setInterval(loadMessages, 2000);
  }

  async function loadMessages() {
    if (!peerID || !token) return;

    try {
      const res = await fetch(`${API_BASE}/messages?peer_id=${peerID}`, {
        headers: { "Authorization": "Bearer " + token }
      });
      const data = await res.json();
      const msgs = data.messages || [];
      const chatEl = document.getElementById("chat");

      const peerPubJwk = await fetchPeerPubKey(peerID);
      const isNew = msgs.length > lastMessagesCount;
      let html = "";

      for (const m of msgs) {
        const cls = (m.from_id === myID) ? "msg me" : "msg";
        let text = "[–Ω–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏]";
        let extraHtml = "";

        if (m.msg_type === "file" && m.file_id && m.file_name) {
          // —Ñ–∞–π–ª ‚Äî —Ç–µ–∫—Å—Ç —É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—ñ –º–æ–∂–µ –±—É—Ç–∏ –æ–ø–∏—Å–æ–º, –∞ –∫–æ–Ω—Ç–µ–Ω—Ç —Å–∫–∞—á—É–≤–∞—Ç–∏ –æ–∫—Ä–µ–º–æ
          text = m.text || "–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–π —Ñ–∞–π–ª";
          extraHtml = `<div class="msg-file-link" onclick="downloadFile(${m.file_id}, '${m.iv}')">üìé ${m.file_name}</div>`;
        } else {
          try {
            text = await decryptFromPeer(m.ciphertext, m.iv, peerPubJwk);
          } catch (e) {
            console.warn("–ü–æ–º–∏–ª–∫–∞ –¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è", e);
          }
        }

        const date = new Date(m.created_at);
        const hh = String(date.getHours()).padStart(2, "0");
        const mm = String(date.getMinutes()).padStart(2, "0");

        html += `
          <div class="${cls}">
            <div>${text}</div>
            ${extraHtml}
            <div class="msg-meta">${hh}:${mm}</div>
          </div>
        `;
      }

      chatEl.innerHTML = html;
      chatEl.scrollTop = chatEl.scrollHeight;

      if (isNew && navigator.vibrate) {
        navigator.vibrate(40);
      }

      lastMessagesCount = msgs.length;
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å:", e);
    }
  }

  function onTyping() {
    const typingEl = document.getElementById("typing-indicator");
    typingEl.textContent = "–¢–∏ –¥—Ä—É–∫—É—î—à‚Ä¶";

    if (typingTimeout) clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => {
      typingEl.textContent = "";
    }, 1200);
  }

  async function sendMessage() {
    const input = document.getElementById("msg");
    const msg = input.value.trim();
    if (!msg || !peerID) return;

    try {
      const peerPubJwk = await fetchPeerPubKey(peerID);
      const { iv, ciphertext } = await encryptTextForPeer(msg, peerPubJwk);

      await fetch(`${API_BASE}/messages`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + token
        },
        body: JSON.stringify({
          to: peerID,
          iv: iv,
          ciphertext: ciphertext,
          msg_type: "text"
        })
      });

      input.value = "";
      await loadMessages();
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è:", e);
      showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (E2EE)", true);
    }
  }

  // ==== E2EE FILES ====
  async function sendFile() {
    if (!peerID || !token) {
      showToast("–°–ø–æ—á–∞—Ç–∫—É –≤–∏–±–µ—Ä–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞", true);
      return;
    }

    const fileInput = document.getElementById("file-input");
    const file = fileInput.files[0];
    if (!file) {
      showToast("–í–∏–±–µ—Ä–∏ —Ñ–∞–π–ª –¥–ª—è –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è", true);
      return;
    }

    try {
      const peerPubJwk = await fetchPeerPubKey(peerID);

      const arrayBuffer = await file.arrayBuffer();
      const { iv, ciphertext } = await encryptBytesForPeer(arrayBuffer, peerPubJwk);

      const formData = new FormData();
      // —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç —è–∫ Blob + –º–µ—Ç–∞–¥–∞–Ω—ñ
      const blob = new Blob([base64ToBuf(ciphertext)]);
      formData.append("file", blob, file.name + ".enc");
      formData.append("to", String(peerID));
      formData.append("iv", iv);
      formData.append("orig_name", file.name);
      formData.append("orig_type", file.type || "application/octet-stream");

      const res = await fetch(`${API_BASE}/files/upload`, {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + token
        },
        body: formData
      });
      if (!res.ok) {
        showToast("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É", true);
        return;
      }

      // —Å–µ—Ä–≤–µ—Ä —Å—Ç–≤–æ—Ä—é—î –∑–∞–ø–∏—Å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ msg_type="file"
      await loadMessages();
      fileInput.value = "";
      showToast("–§–∞–π–ª –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ (E2EE)");
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ E2EE —Ñ–∞–π–ª—É:", e);
      showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞—à–∏—Ñ—Ä—É–≤–∞—Ç–∏/–≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ —Ñ–∞–π–ª", true);
    }
  }

  async function downloadFile(fileId, iv) {
    if (!token) return;

    try {
      const res = await fetch(`${API_BASE}/files/${fileId}`, {
        headers: { "Authorization": "Bearer " + token }
      });
      if (!res.ok) {
        showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–∞–π–ª", true);
        return;
      }

      const arrayBuffer = await res.arrayBuffer();
      const peerPubJwk = await fetchPeerPubKey(peerID);
      const plainBuf = await decryptBytesFromPeer(arrayBuffer, iv, peerPubJwk);

      const blob = new Blob([plainBuf]);
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "spysignal_file";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è/–¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è —Ñ–∞–π–ª—É:", e);
      showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –≤—ñ–¥–∫—Ä–∏—Ç–∏ —Ñ–∞–π–ª", true);
    }
  }

  // ==== WEBRTC CALLS ====
  async function initLocalMedia() {
    if (localStream) return;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      localAudio.srcObject = localStream;
    } catch (e) {
      console.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –º—ñ–∫—Ä–æ—Ñ–æ–Ω:", e);
      showToast("–î–æ–∑–≤–æ–ª—å –¥–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞", true);
    }
  }

  function createPeerConnection() {
    const configuration = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" }
      ]
    };
    pc = new RTCPeerConnection(configuration);

    if (localStream) {
      for (const track of localStream.getTracks()) {
        pc.addTrack(track, localStream);
      }
    }

    pc.ontrack = (event) => {
      remoteAudio.srcObject = event.streams[0];
    };

    pc.onicecandidate = (event) => {
      if (event.candidate && currentCallPeerId) {
        sendIceCandidate(currentCallPeerId, event.candidate);
      }
    };

    pc.onconnectionstatechange = () => {
      const st = pc.connectionState;
      const el = document.getElementById("call-status");
      el.textContent = "–°—Ç–∞—Ç—É—Å –¥–∑–≤—ñ–Ω–∫–∞: " + st;
      if (st === "disconnected" || st === "failed" || st === "closed") {
        endCallLocal();
      }
    };
  }

  async function sendIceCandidate(to, candidate) {
    try {
      await fetch(`${API_BASE}/call/candidate`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + token
        },
        body: JSON.stringify({
          to,
          candidate
        })
      });
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è ICE:", e);
    }
  }

  async function startCall() {
    if (!peerID || !token) {
      showToast("–°–ø–æ—á–∞—Ç–∫—É –≤–∏–±–µ—Ä–∏ —Å–ø—ñ–≤—Ä–æ–∑–º–æ–≤–Ω–∏–∫–∞", true);
      return;
    }

    await initLocalMedia();
    createPeerConnection();
    currentCallPeerId = peerID;

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    try {
      await fetch(`${API_BASE}/call/offer`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + token
        },
        body: JSON.stringify({
          to: peerID,
          sdp: offer.sdp
        })
      });
      document.getElementById("call-status").textContent = "–í–∏–∫–ª–∏–∫ –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ‚Ä¶";
      document.getElementById("btn-call").classList.add("end");
      document.getElementById("btn-call").textContent = "üõë End";
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ offer:", e);
      showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è —ñ–Ω—ñ—Ü—ñ—é–≤–∞—Ç–∏ –¥–∑–≤—ñ–Ω–æ–∫", true);
    }
  }

  function endCallLocal() {
    if (pc) {
      pc.close();
      pc = null;
    }
    currentCallPeerId = null;
    document.getElementById("btn-call").classList.remove("end");
    document.getElementById("btn-call").textContent = "üìû Call";
    document.getElementById("call-status").textContent = "–î–∑–≤—ñ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–æ";
  }

  function toggleCall() {
    if (pc && currentCallPeerId) {
      endCallLocal();
    } else {
      startCall();
    }
  }

  async function handleIncomingOffer(from_id, sdp) {
    await initLocalMedia();
    createPeerConnection();
    currentCallPeerId = from_id;

    await pc.setRemoteDescription({ type: "offer", sdp });

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    try {
      await fetch(`${API_BASE}/call/answer`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + token
        },
        body: JSON.stringify({
          to: from_id,
          sdp: answer.sdp
        })
      });
      document.getElementById("call-status").textContent = "–í—Ö—ñ–¥–Ω–∏–π –¥–∑–≤—ñ–Ω–æ–∫ ‚Äî –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è‚Ä¶";
      document.getElementById("btn-call").classList.add("end");
      document.getElementById("btn-call").textContent = "üõë End";
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ answer:", e);
      showToast("–ù–µ –≤–¥–∞–ª–æ—Å—è –≤—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏ –Ω–∞ –¥–∑–≤—ñ–Ω–æ–∫", true);
    }
  }

  async function handleIncomingAnswer(from_id, sdp) {
    if (!pc) return;
    await pc.setRemoteDescription({ type: "answer", sdp });
    document.getElementById("call-status").textContent = "–î–∑–≤—ñ–Ω–æ–∫ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ";
  }

  async function handleIncomingCandidate(from_id, candidate) {
    if (!pc) return;
    try {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
    } catch (e) {
      console.error("–ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è ICE", e);
    }
  }

  async function pollCallEvents() {
    if (!token || !myID) return;
    try {
      const url = `${API_BASE}/call/poll?user_id=${myID}&since_id=${lastCallEventId}`;
      const res = await fetch(url, {
        headers: { "Authorization": "Bearer " + token }
      });
      if (!res.ok) return;
      const data = await res.json();
      const events = data.events || [];
      for (const ev of events) {
        lastCallEventId = Math.max(lastCallEventId, ev.id || 0);
        if (ev.type === "offer") {
          await handleIncomingOffer(ev.from_id, ev.sdp);
        } else if (ev.type === "answer") {
          await handleIncomingAnswer(ev.from_id, ev.sdp);
        } else if (ev.type === "candidate") {
          await handleIncomingCandidate(ev.from_id, ev.candidate);
        }
      }
    } catch (e) {
      console.error("pollCallEvents error:", e);
    }
  }

</script>
</body>
</html>